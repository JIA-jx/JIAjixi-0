## [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

![image-20250415082640944](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250415082640944.png)



```c
void setZeroes(int** matrix, int matrixSize, int* matrixColSize) {
    int m = matrixSize;
    int n = matrixColSize[0];
    
    int row[m], col[n]; // 行标记 列标记 
    memset(row, 0, sizeof(row)); // 置零 
    memset(col, 0, sizeof(col));
    // 遍历标记需要置零的行与列 
	for (int i = 0; i < m; i ++)
	{
        for (int j = 0; j < n; j ++)
		{
            if (0 == matrix[i][j])
			{
                row[i] = col[j] = true;
            }
        }
    }
    // 如果标记为 true，则对其置零 
    for (int i = 0; i < m; i ++)
	{
        for (int j = 0; j < n; j ++)
		{
            if (row[i] == true || col[j] == true)
			{
                matrix[i][j] = 0;
            }
        }
    }
}
```



## [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)

![image-20250415083542072](https://jiajixi-0.oss-cn-beijing.aliyuncs.com/image-20250415083542072.png)



```c
struct ListNode* rotateRight(struct ListNode* head, int k) {
    // 空链表
    if (head == NULL || head->next == NULL || k == 0)
	{
        return head;
    }

    struct ListNode *curr = head;
    int cnt = 1;
    // 计算链表长度
    while (curr->next != NULL)
	{
        cnt ++;
        curr = curr->next;
    }

    // 计算实际需要旋转的次数
    k = k % cnt;
    if (k == 0)
	{
        return head;
    }
    // 尾首相连 
    curr->next = head;
    // 找到新尾节点
    int n = cnt - k;
    while (n > 0)
	{
		n --;
        curr = curr->next;
    }
    // 断开链表
    struct ListNode *newHead = curr->next;
    curr->next = NULL;

    return newHead;
}
```

